// Copyright 2020 The Tilt Brush Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using UnityEngine;

namespace TiltBrush
{

    class PrintableBrush : GeometryBrush
    {
        protected const int BR = 0; // back  right
        protected const int BL = 1; // back  left
        protected const int BT = 2; // back  top
        protected const int BB = 3; // back  bottom
        protected const int FR = 4; // front right
        protected const int FL = 5; // front left
        protected const int FT = 6; // front top
        protected const int FB = 7; // front bottom

        const float kSolidMinLengthMeters_PS = 0.002f;
        const float kMinMoveLengthMeters_PS = 5e-4f;
        const float kBreakAngleScalar = 2.0f;
        const float kSolidAspectRatio = 0.2f;
        const float kCrossSectionAspectRatio = .375f; // height / width

        public bool m_UseEnvelope = false;

        public PrintableBrush()
            : base(bCanBatch: true,
                upperBoundVertsPerKnot: 4,
                bDoubleSided: false)
        {
        }

        //
        // GeometryBrush API
        //

        protected override void InitBrush(BrushDescriptor desc,
                                          TrTransform localPointerXf)
        {
            base.InitBrush(desc, localPointerXf);
            m_geometry.Layout = GetVertexLayout(desc);
        }

        override public GeometryPool.VertexLayout GetVertexLayout(BrushDescriptor desc)
        {
            return new GeometryPool.VertexLayout
            {
                // Don't use UVs, but don't want to write another shader that doesn't sample
                uv0Size = 2,
                bUseNormals = true,
                bUseColors = true,
            };
        }

        override public float GetSpawnInterval(float pressure01)
        {
            return kSolidMinLengthMeters_PS * POINTER_TO_LOCAL * App.METERS_TO_UNITS +
                (PressuredSize(pressure01) * kSolidAspectRatio);
        }

        override protected void ControlPointsChanged(int iKnot0)
        {
            // Frames knots, determines how much geometry each knot should get
            OnChanged_FrameKnots(iKnot0);
            OnChanged_SetEnvelope(iKnot0);
            ResizeGeometry();

            // Updating a control point affects geometry generated by previous knot
            // (if there is any). The HasGeometry check is not a micro-optimization:
            // it also keeps us from backing up past knot 0.
            {
                int start = (m_knots[iKnot0 - 1].HasGeometry) ? iKnot0 - 1 : iKnot0;
                OnChanged_MakeGeometry(start);
            }
        }

        void SetKnotEnvelope(int i, float width)
        {
            Knot k = m_knots[i];
            k.qFrame.x = width;
            m_knots[i] = k;
        }

        const float kInitialEnvelope = .8f;
        const float kFinalEnvelope = .3f;
        // To approximate the shape of the tapered marker with geometry, calculate
        // an envelope. Envelope of the first knot is .8.  The _second_ through end
        // knots lerp from 1 down to .3.
        void OnChanged_SetEnvelope(int iKnot0)
        {
            int i0 = 0;
            int n = m_knots.Count;
            while (i0 < n)
            {
                // Find the longest span of non-break knots.
                int i1 = i0 + 1;
                float totalLength = 0;
                for (; i1 < n && m_knots[i1].HasGeometry; ++i1)
                {
                    totalLength += m_knots[i1].length;
                }

                // Invariant: i0 is a break
                // Invariant: i1 > i0 and is also a break
                // Invariant: [i0, i1) are non-breaks (except for i0)

                SetKnotEnvelope(i0, kInitialEnvelope);

                if (i0 + 1 < i1)
                {
                    // Chop off the first length, because the lerp starts at the second knot
                    totalLength -= m_knots[i0 + 1].length;
                    SetKnotEnvelope(i0 + 1, 1f);

                    float curLength = 0;
                    for (int i = i0 + 2; i < i1; ++i)
                    {
                        curLength += m_knots[i].length;
                        // choose t=1 for the degenerate case of 0/0
                        float t = (curLength >= totalLength) ? 1f : curLength / totalLength;
                        SetKnotEnvelope(i, 1 * (1 - t) + kFinalEnvelope * t);
                    }
                }

                i0 = i1;
            }
        }

        // Fills in any knot data needed for geometry generation. Updates:
        // - length, nRight, nSurface
        // - HasGeometry, startsGeometry, endsGeometry
        // - iVert, nVert, iTri, nTri
        void OnChanged_FrameKnots(int iKnot0)
        {
            float minMove = kMinMoveLengthMeters_PS * App.METERS_TO_UNITS * POINTER_TO_LOCAL;

            Knot prev = m_knots[iKnot0 - 1];
            for (int iKnot = iKnot0; iKnot < m_knots.Count; ++iKnot)
            {
                Knot cur = m_knots[iKnot];

                bool shouldBreak = false;

                Vector3 vMove = cur.point.m_Pos - prev.point.m_Pos;
                cur.length = vMove.magnitude;

                // Rather than use unstable math, just bail and don't change the geometry.
                if (cur.length < minMove)
                {
                    // nb. it's only safe to bail if we haven't already started changing state
                    // (thus the assert that this is the last knot). We also only expect this to
                    // happen for the dynamic leading edge (thus the assert that this is the first
                    // knot in the update list).
                    shouldBreak = true;
                }

                // invariant: nSurface = nMove x nRight
                // If single-sided, always point the frontside towards the brush. Causes twisting.
                Vector3 nMove = vMove / cur.length;
                Vector3 vPreferredRight = m_Desc.m_BackIsInvisible
                    ? Vector3.Cross(cur.point.m_Orient * Vector3.forward, nMove)
                    : prev.nRight;
                ComputeSurfaceFrameNew(
                    vPreferredRight, nMove, cur.point.m_Orient,
                    out cur.nRight, out cur.nSurface);

                // More break checking; replicates previous logic
                if (prev.HasGeometry)
                {
                    float fWidthHeightRatio = cur.length / PressuredSize(cur.smoothedPressure);
                    float fBreakAngle = Mathf.Atan(fWidthHeightRatio) * Mathf.Rad2Deg * kBreakAngleScalar;
                    Vector3 vPrevMove = prev.point.m_Pos - m_knots[iKnot - 2].point.m_Pos;
                    if (Vector3.Angle(vPrevMove, vMove) > fBreakAngle)
                    {
                        shouldBreak = true;
                    }
                }

                if (shouldBreak)
                {
                    // These things are documented as being invalid unless HasGeometry,
                    // so technically we don't need to null them out
                    cur.nRight = cur.nSurface = Vector3.zero;
                    cur.startsGeometry = cur.endsGeometry = false;

                    // nb: duplicated down below too
                    if (prev.HasGeometry && !prev.endsGeometry)
                    {
                        prev.endsGeometry = true;
                        prev.nTri += 2;
                        m_knots[iKnot - 1] = prev;
                    }

                    cur.iTri = prev.iTri + prev.nTri;
                    cur.iVert = (ushort)(prev.iVert + prev.nVert);
                    cur.nTri = cur.nVert = (ushort)0;
                }
                else
                {
                    if (prev.HasGeometry && prev.endsGeometry)
                    {
                        prev.endsGeometry = false;
                        prev.nTri -= 2;
                        m_knots[iKnot - 1] = prev;
                    }

                    cur.startsGeometry = !prev.HasGeometry;
                    cur.endsGeometry = false; // this will be fixed up next iteration
                    cur.nVert = 8;
                    cur.nTri = 8;
                    cur.iTri = prev.iTri + prev.nTri;
                    if (cur.startsGeometry)
                    {
                        // no shared verts with previous.
                        // 2 extra triangles for start cap.
                        cur.iVert = (ushort)(prev.iVert + prev.nVert);
                        cur.nTri += 2;
                    }
                    else
                    {
                        // 4 shared verts with previous.
                        cur.iVert = (ushort)(prev.iVert + prev.nVert - 4);
                    }
                }

                m_knots[iKnot] = cur;
                prev = cur;
            }

            // nb: copied from the loop
            if (prev.HasGeometry && !prev.endsGeometry)
            {
                prev.endsGeometry = true;
                prev.nTri += 2;
                m_knots[m_knots.Count - 1] = prev;
            }
        }

        // Create verts, tris
        void OnChanged_MakeGeometry(int iKnot0)
        {

            // Invariant: there is a previous knot.
            Knot prev = m_knots[iKnot0 - 1];

            for (int iKnot = iKnot0; iKnot < m_knots.Count; ++iKnot)
            {
                // Invariant: all of prev's geometry (if any) is correct and up-to-date.
                // Thus, there is no need to modify anything shared with prev.
                Knot cur = m_knots[iKnot];

                if (cur.HasGeometry)
                {
                    int nTri = 0;

                    // Top quads
                    SetTri(cur.iTri, cur.iVert, nTri++, BT, BL, FT);
                    SetTri(cur.iTri, cur.iVert, nTri++, FT, BL, FL);
                    SetTri(cur.iTri, cur.iVert, nTri++, BT, FT, BR);
                    SetTri(cur.iTri, cur.iVert, nTri++, BR, FT, FR);
                    // Bottom quads
                    SetTri(cur.iTri, cur.iVert, nTri++, BB, FB, BL);
                    SetTri(cur.iTri, cur.iVert, nTri++, BL, FB, FL);
                    SetTri(cur.iTri, cur.iVert, nTri++, BB, BR, FB);
                    SetTri(cur.iTri, cur.iVert, nTri++, FB, BR, FR);
                    // Endcaps
                    if (cur.startsGeometry)
                    {
                        SetTri(cur.iTri, cur.iVert, nTri++, BT, BR, BL);
                        SetTri(cur.iTri, cur.iVert, nTri++, BL, BR, BB);
                    }
                    if (cur.endsGeometry)
                    {
                        SetTri(cur.iTri, cur.iVert, nTri++, FT, FL, FR);
                        SetTri(cur.iTri, cur.iVert, nTri++, FR, FL, FB);
                    }
                    Debug.Assert(nTri == cur.nTri);

                    if (cur.startsGeometry)
                    {
                        // Can't use prev.nRight, prev.nSurface; they're invalid if no geometry
                        float size = PressuredSize(prev.smoothedPressure) * prev.qFrame.x;
                        Vector3 halfR = cur.nRight * (size / 2);
                        Vector3 halfU = cur.nSurface * ((size / 2) * kCrossSectionAspectRatio);
                        MySetVert(cur.iVert, BR, prev.point.m_Pos + halfR, cur.nRight);
                        MySetVert(cur.iVert, BL, prev.point.m_Pos - halfR, -cur.nRight);
                        MySetVert(cur.iVert, BT, prev.point.m_Pos + halfU, cur.nSurface);
                        MySetVert(cur.iVert, BB, prev.point.m_Pos - halfU, -cur.nSurface);
                    }

                    {
                        float size = PressuredSize(cur.smoothedPressure) * cur.qFrame.x;
                        Vector3 halfR = cur.nRight * (size / 2);
                        Vector3 halfU = cur.nSurface * ((size / 2) * kCrossSectionAspectRatio);
                        MySetVert(cur.iVert, FR, cur.point.m_Pos + halfR, cur.nRight);
                        MySetVert(cur.iVert, FL, cur.point.m_Pos - halfR, -cur.nRight);
                        MySetVert(cur.iVert, FT, cur.point.m_Pos + halfU, cur.nSurface);
                        MySetVert(cur.iVert, FB, cur.point.m_Pos - halfU, -cur.nSurface);
                    }
                }

                prev = cur;
            }
        }

        void MySetVert(int iVert, int vp, Vector3 v, Vector3 n)
        {
            int i = iVert + vp * NS;
            m_geometry.m_Vertices[i] = v;
            m_geometry.m_Normals[i] = n;
            Color32 c = m_Color;
            c.a = 255;
            m_geometry.m_Colors[i] = c;
            m_geometry.m_Texcoord0.v2[i] = new Vector2(.5f, .5f);
        }

    }
} // namespace TiltBrush
